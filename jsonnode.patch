commit c7b811b5b1e073378656aed3a509c77031c041a7
Author: Andrew Jeddeloh <andrew.jeddeloh@coreos.com>
Date:   Tue Jul 19 15:13:47 2016 -0700

    modified decode

diff --git a/decode.go b/decode.go
index 530e852..a8b2db0 100644
--- a/decode.go
+++ b/decode.go
@@ -125,6 +125,14 @@ type InvalidUnmarshalError struct {
 	Type reflect.Type
 }
 
+type Node struct {
+	Start    int
+	End      int
+	KeyStart int // Only value if a member of a struct
+	KeyEnd   int
+	Value    interface{}
+}
+
 func (e *InvalidUnmarshalError) Error() string {
 	if e.Type == nil {
 		return "json: Unmarshal(nil)"
@@ -154,7 +162,12 @@ func (d *decodeState) unmarshal(v interface{}) (err error) {
 	d.scan.reset()
 	// We decode rv not rv.Elem because the Unmarshaler interface
 	// test must be applied at the top level of the value.
-	d.value(rv)
+	if rv.Type() == reflect.TypeOf(&Node{}) {
+		toset := reflect.ValueOf(d.valueNode())
+		rv.Elem().Set(toset)
+	} else {
+		d.value(rv)
+	}
 	return d.savedError
 }
 
@@ -404,6 +417,11 @@ func (d *decodeState) array(v reflect.Value) {
 		// Otherwise it's invalid.
 		fallthrough
 	default:
+		if v.Type() == reflect.TypeOf(Node{}) {
+			// Decoding to Node? Switch to that code
+			v.Set(reflect.ValueOf(d.arrayNode()))
+			return
+		}
 		d.saveError(&UnmarshalTypeError{"array", v.Type(), int64(d.off)})
 		d.off--
 		d.next()
@@ -504,6 +522,9 @@ func (d *decodeState) object(v reflect.Value) {
 	if v.Kind() == reflect.Interface && v.NumMethod() == 0 {
 		v.Set(reflect.ValueOf(d.objectInterface()))
 		return
+	} else if v.Type() == reflect.TypeOf(Node{}) {
+		v.Set(reflect.ValueOf(d.objectNode()))
+		return
 	}
 
 	// Check type of target: struct or map[string]T
@@ -846,6 +867,22 @@ func (d *decodeState) valueInterface() interface{} {
 	}
 }
 
+// valueNode is like valueInterface but returns a wrapped version that
+// contains metadata about where it decoded from
+func (d *decodeState) valueNode() Node {
+	switch d.scanWhile(scanSkipSpace) {
+	default:
+		d.error(errPhase)
+		panic("unreachable")
+	case scanBeginArray:
+		return d.arrayNode()
+	case scanBeginObject:
+		return d.objectNode()
+	case scanBeginLiteral:
+		return d.literalNode()
+	}
+}
+
 // arrayInterface is like array but returns []interface{}.
 func (d *decodeState) arrayInterface() []interface{} {
 	var v = make([]interface{}, 0)
@@ -874,6 +911,40 @@ func (d *decodeState) arrayInterface() []interface{} {
 	return v
 }
 
+// arrayNode is like arrayInterface but returns Node.
+func (d *decodeState) arrayNode() Node {
+	var v = make([]Node, 0)
+	node := Node{
+		Start: d.off,
+		Value:  v,
+	}
+	for {
+		// Look ahead for ] - can only happen on first iteration.
+		op := d.scanWhile(scanSkipSpace)
+		if op == scanEndArray {
+			break
+		}
+
+		// Back up so d.value can have the byte we just read.
+		d.off--
+		d.scan.undo(op)
+
+		v = append(v, d.valueNode())
+
+		// Next token must be , or ].
+		op = d.scanWhile(scanSkipSpace)
+		if op == scanEndArray {
+			break
+		}
+		if op != scanArrayValue {
+			d.error(errPhase)
+		}
+	}
+	node.Value = v
+	node.End = d.off
+	return node
+}
+
 // objectInterface is like object but returns map[string]interface{}.
 func (d *decodeState) objectInterface() map[string]interface{} {
 	m := make(map[string]interface{})
@@ -920,6 +991,60 @@ func (d *decodeState) objectInterface() map[string]interface{} {
 	return m
 }
 
+// objectNode is like object but returns Node.
+func (d *decodeState) objectNode() Node {
+	m := make(map[string]Node)
+	node := Node {
+		Start: d.off,
+	}
+	for {
+		// Read opening " of string key or closing }.
+		op := d.scanWhile(scanSkipSpace)
+		if op == scanEndObject {
+			// closing } - can only happen on first iteration.
+			break
+		}
+		if op != scanBeginLiteral {
+			d.error(errPhase)
+		}
+
+		// Read string key.
+		start := d.off - 1
+		op = d.scanWhile(scanContinue)
+		item := d.data[start : d.off-1]
+		key, ok := unquote(item)
+		if !ok {
+			d.error(errPhase)
+		}
+
+		// Read : before value.
+		if op == scanSkipSpace {
+			op = d.scanWhile(scanSkipSpace)
+		}
+		if op != scanObjectKey {
+			d.error(errPhase)
+		}
+
+		// Read value.
+		val := d.valueNode()
+		val.KeyStart = start
+		val.KeyEnd = d.off
+		m[key] = val
+
+		// Next token must be , or }.
+		op = d.scanWhile(scanSkipSpace)
+		if op == scanEndObject {
+			break
+		}
+		if op != scanObjectValue {
+			d.error(errPhase)
+		}
+	}
+	node.Value = m
+	node.End = d.off
+	return node
+}
+
 // literalInterface is like literal but returns an interface value.
 func (d *decodeState) literalInterface() interface{} {
 	// All bytes inside literal return scanContinue op code.
@@ -957,6 +1082,17 @@ func (d *decodeState) literalInterface() interface{} {
 	}
 }
 
+func (d *decodeState) literalNode() Node {
+	start := d.off - 1
+	// Can just shell out to the interface version since this has no children
+	node := Node {
+		Start: start,
+		Value:  d.literalInterface(),
+	}
+	node.End = d.off
+	return node
+}
+
 // getu4 decodes \uXXXX from the beginning of s, returning the hex value,
 // or it returns -1.
 func getu4(s []byte) rune {
